% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/day17_v2.R
\name{dijkstra}
\alias{dijkstra}
\title{dijkstra <- function(grid, start, dir = -1){
#' Implementation of dijkstra using on-demand query
#' derived from https://www.algorithms-and-technologies.com/dijkstra/r
#' This returns an array containing the length of the shortest path from the start node to each other node.
#' It is only guaranteed to return correct results if there are no negative edges in the graph. Positive cycles are fine.
#' This has a runtime of O(|V|^2) (|V| = number of Nodes), for a faster implementation see @see ../fast/Dijkstra.java (using adjacency lists)
#' @param graph an adjacency-matrix-representation of the graph where (x,y) is the weight of the edge or 0 if there is no edge.
#' @param start the node to start from.
#' @param dir are we going up or down? passed to can_reach()
#' @return an array containing the shortest distances from the given start node to each other nodeThis contains the distances from the start node to all other nodes

distances = rep(Inf, prod(dim(grid)))
paths = rep(list(), prod(dim(grid)))This contains whether a node was already visited

visited = rep(FALSE, prod(dim(grid)))The distance from the start node to itself is of course 0

distances\link{start} = 0
paths[\link{start}] = startWhile there are nodes left to visit...

repeat{

\if{html}{\out{<div class="sourceCode">}}\preformatted{# ... find the node with the currently shortest distance from the start node...
shortest_distance = Inf
shortest_index = -1
for(i in seq_along(distances)) \{
  # ... by going through all nodes that haven't been visited yet
  if(distances[i] < shortest_distance && !visited[i])\{
    shortest_distance = distances[i]
    shortest_index = i
  \}
\}

# cat("Visiting node ", shortest_index, " with current distance ", shortest_distance, "\\n")

if(shortest_index == -1)\{
  # There was no node not yet visited --> We are done
  return (list(distances, paths))
\}
# ...then, for all neighboring nodes that haven't been visited yet....
# for(i in seq_along(graph[shortest_index,])) \{
g <- can_reach(grid)[shortest_index,]*ngrid
for(i in seq_along(g)) \{
  # ...if the path over this edge is shorter...
  # if(graph[shortest_index,i] != 0 && distances[i] > distances[shortest_index] + graph[shortest_index,i])\{
  # if recently more than 3 same row or 3 same col, make Inf
  rec <- tail(c(paths[[shortest_index]], i), 5)
  pos <- sapply(rec, \\(w) get_pos(grid, w))
  # if (any(table(pos[1,]) == 5) | any(table(pos[2,]) == 5)) \{
  if (any(rle(rev(pos[1,]))$lengths > 4) | any(rle(rev(pos[2,]))$lengths > 4)) \{
    g[i] <- 0
  \}
  if(g[i] != 0 && distances[i] >= distances[shortest_index] + g[i])\{
    # ...Save this path as new shortest path.
    distances[i] = distances[shortest_index] + g[i]
    paths[[i]] <- c(paths[[shortest_index]], i)
    
    
    # cat("Updating distance of node ", i, " to ", distances[i], "\\n")
  \}
  # Lastly, note that we are finished with this node.
  visited[shortest_index] = TRUE
  # cat("Visited nodes: ", visited, "\\n")
  # cat("Currently lowest distances: ", distances, "\\n")
\}
}\if{html}{\out{</div>}}

}
}}
\usage{
dijkstra(graph, start, end)
}
\description{
dijkstra <- function(grid, start, dir = -1){
#' Implementation of dijkstra using on-demand query
#' derived from https://www.algorithms-and-technologies.com/dijkstra/r
#' This returns an array containing the length of the shortest path from the start node to each other node.
#' It is only guaranteed to return correct results if there are no negative edges in the graph. Positive cycles are fine.
#' This has a runtime of O(|V|^2) (|V| = number of Nodes), for a faster implementation see @see ../fast/Dijkstra.java (using adjacency lists)
#' @param graph an adjacency-matrix-representation of the graph where (x,y) is the weight of the edge or 0 if there is no edge.
#' @param start the node to start from.
#' @param dir are we going up or down? passed to can_reach()
#' @return an array containing the shortest distances from the given start node to each other nodeThis contains the distances from the start node to all other nodes

distances = rep(Inf, prod(dim(grid)))
paths = rep(list(), prod(dim(grid)))This contains whether a node was already visited

visited = rep(FALSE, prod(dim(grid)))The distance from the start node to itself is of course 0

distances\link{start} = 0
paths[\link{start}] = startWhile there are nodes left to visit...

repeat{

\if{html}{\out{<div class="sourceCode">}}\preformatted{# ... find the node with the currently shortest distance from the start node...
shortest_distance = Inf
shortest_index = -1
for(i in seq_along(distances)) \{
  # ... by going through all nodes that haven't been visited yet
  if(distances[i] < shortest_distance && !visited[i])\{
    shortest_distance = distances[i]
    shortest_index = i
  \}
\}

# cat("Visiting node ", shortest_index, " with current distance ", shortest_distance, "\\n")

if(shortest_index == -1)\{
  # There was no node not yet visited --> We are done
  return (list(distances, paths))
\}
# ...then, for all neighboring nodes that haven't been visited yet....
# for(i in seq_along(graph[shortest_index,])) \{
g <- can_reach(grid)[shortest_index,]*ngrid
for(i in seq_along(g)) \{
  # ...if the path over this edge is shorter...
  # if(graph[shortest_index,i] != 0 && distances[i] > distances[shortest_index] + graph[shortest_index,i])\{
  # if recently more than 3 same row or 3 same col, make Inf
  rec <- tail(c(paths[[shortest_index]], i), 5)
  pos <- sapply(rec, \\(w) get_pos(grid, w))
  # if (any(table(pos[1,]) == 5) | any(table(pos[2,]) == 5)) \{
  if (any(rle(rev(pos[1,]))$lengths > 4) | any(rle(rev(pos[2,]))$lengths > 4)) \{
    g[i] <- 0
  \}
  if(g[i] != 0 && distances[i] >= distances[shortest_index] + g[i])\{
    # ...Save this path as new shortest path.
    distances[i] = distances[shortest_index] + g[i]
    paths[[i]] <- c(paths[[shortest_index]], i)
    
    
    # cat("Updating distance of node ", i, " to ", distances[i], "\\n")
  \}
  # Lastly, note that we are finished with this node.
  visited[shortest_index] = TRUE
  # cat("Visited nodes: ", visited, "\\n")
  # cat("Currently lowest distances: ", distances, "\\n")
\}
}\if{html}{\out{</div>}}

}
}
}
